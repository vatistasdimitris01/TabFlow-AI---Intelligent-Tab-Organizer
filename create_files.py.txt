import os
import json

# TabFlow AI - Extension Bridge Setup Script
# Use this to generate the local browser extension.
# The Web Dashboard should be deployed to Vercel separately.

def setup_extension():
    folder = "tabflow_extension"
    
    files = {
        "manifest.json": json.dumps({
            "manifest_version": 3,
            "name": "TabFlow AI Bridge",
            "version": "1.0.5",
            "description": "Bridges real browser tabs with your TabFlow AI Dashboard.",
            "permissions": ["tabs", "tabGroups", "storage"],
            "host_permissions": ["<all_urls>"],
            "background": {"service_worker": "background.js"},
            "content_scripts": [{
                "matches": ["<all_urls>"],
                "js": ["content.js"],
                "run_at": "document_start"
            }],
            "action": {
                "default_popup": "popup.html",
                "default_icon": "icon.svg"
            },
            "icons": {"128": "icon.svg"}
        }, indent=2),

        "background.js": """chrome.runtime.onMessage.addListener((req, sender, sendResponse) => {
  if (req.action === 'GET_TABS') {
    chrome.tabs.query({}, (tabs) => {
      sendResponse({ 
        tabs: tabs.map(t => ({ 
          id: t.id.toString(), 
          url: t.url, 
          title: t.title, 
          favIconUrl: t.favIconUrl, 
          groupId: t.groupId 
        })) 
      });
    });
    return true; 
  }

  if (req.action === 'TAB_ACTION') {
    const { action, tabId } = req.data;
    if (action === 'CLOSE') {
      chrome.tabs.remove(tabId);
    } else if (action === 'FOCUS') {
      chrome.tabs.update(tabId, { active: true });
      chrome.tabs.get(tabId, (t) => chrome.windows.update(t.windowId, { focused: true }));
    }
  }

  if (req.action === 'APPLY_GROUPS') {
    req.data.forEach(async (g) => {
      const tabIds = g.tabIds.map(id => parseInt(id)).filter(id => !isNaN(id));
      if (tabIds.length > 0) {
        try {
          const groupId = await chrome.tabs.group({ tabIds });
          const colors = ['grey', 'blue', 'red', 'yellow', 'green', 'pink', 'purple', 'cyan', 'orange'];
          chrome.tabGroups.update(groupId, { 
            title: g.name, 
            color: colors[Math.floor(Math.random() * colors.length)] 
          });
        } catch (e) {}
      }
    });
  }
});

chrome.tabs.onUpdated.addListener(() => broadcast());
chrome.tabs.onRemoved.addListener(() => broadcast());

async function broadcast() {
  const tabs = await chrome.tabs.query({});
  const data = tabs.map(t => ({ id: t.id.toString(), url: t.url, title: t.title, favIconUrl: t.favIconUrl, groupId: t.groupId }));
  chrome.tabs.query({ active: true }, (activeTabs) => {
    activeTabs.forEach(t => {
      chrome.tabs.sendMessage(t.id, { action: 'TABS_UPDATE', data }).catch(() => {});
    });
  });
}""",

        "content.js": """window.addEventListener('message', (e) => {
  if (e.data?.source !== 'tabflow-page') return;
  if (e.data.action === 'PING') {
    window.postMessage({ source: 'tabflow-extension', action: 'PONG' }, '*');
    return;
  }
  chrome.runtime.sendMessage({ action: e.data.action, data: e.data.data }, (res) => {
    if (res?.tabs) {
      window.postMessage({ source: 'tabflow-extension', action: 'TABS_UPDATE', data: res.tabs }, '*');
    }
  });
});

chrome.runtime.onMessage.addListener((msg) => {
  if (msg.action === 'TABS_UPDATE') {
    window.postMessage({ source: 'tabflow-extension', action: 'TABS_UPDATE', data: msg.data }, '*');
  }
});""",

        "popup.html": """<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body { width: 220px; margin: 0; padding: 16px; font-family: sans-serif; background: #020617; color: white; border-radius: 12px; }
    .logo { width: 28px; height: 28px; background: #2563eb; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: 900; margin-bottom: 12px; }
    .btn { display: block; width: 100%; padding: 12px; background: #2563eb; color: white; border-radius: 8px; font-weight: 700; border: none; cursor: pointer; transition: background 0.2s; }
    .btn:hover { background: #3b82f6; }
    .status { font-size: 11px; color: #64748b; margin-top: 10px; text-align: center; }
  </style>
</head>
<body>
  <div class="logo">T</div>
  <h2 style="font-size: 16px; margin: 0 0 15px 0;">TabFlow <span style="color: #60a5fa">AI</span></h2>
  <button class="btn" id="launch">Launch Dashboard</button>
  <div class="status">Extension Bridge Active</div>
  <script src="popup.js"></script>
</body>
</html>""",

        "popup.js": """document.addEventListener('DOMContentLoaded', () => {
  const launchBtn = document.getElementById('launch');
  // REPLACE WITH YOUR ACTUAL VERCEL URL
  const DASHBOARD_URL = "https://your-app.vercel.app";

  launchBtn.addEventListener('click', () => {
    chrome.tabs.query({ url: DASHBOARD_URL + "/*" }, (tabs) => {
      if (tabs.length > 0) {
        chrome.tabs.update(tabs[0].id, { active: true });
        chrome.windows.update(tabs[0].windowId, { focused: true });
      } else {
        chrome.tabs.create({ url: DASHBOARD_URL });
      }
    });
  });
});""",

        "icon.svg": """<svg width="128" height="128" viewBox="0 0 128 128" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="128" height="128" rx="28" fill="#2563EB"/>
<path d="M36 45H92M36 64H92M36 83H64" stroke="white" stroke-width="8" stroke-linecap="round"/>
</svg>"""
    }

    print(f"--- Creating Extension Folder: ./{folder} ---")
    os.makedirs(folder, exist_ok=True)
    for path, content in files.items():
        full_path = os.path.join(folder, path)
        with open(full_path, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"Created: {full_path}")
    print("\n--- NEXT STEPS ---")
    print("1. Go to chrome://extensions")
    print("2. Click 'Load unpacked' and select the folder you just created.")

if __name__ == "__main__":
    setup_extension()
